抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。
通常在编程语句中用 abstract 修饰的类是抽象类。在C++中，含有纯虚拟函数的类称为抽象类，它不能生成对象；在java中，含有抽象方法的类称为抽象类，同样不能生成对象。
抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。

## 概念理解
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。
比如，在一个图形编辑软件的分析设计过程中，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域并不是直接存在的，它就是一个抽象概念。而正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。
c#中的抽象类的特征
抽象类具有以下特性：
抽象类不能实例化。
抽象类可以包含抽象方法和抽象访问器。
不能用 sealed 修饰符修饰抽象类，因为这两个修饰符的含义是相反的。 采用 sealed 修饰符的类无法继承，而 abstract 修饰符要求对类进行继承。
从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实际实现。

## 比较区别

### 与具体类比较
抽象类不能直接实例化，并且对抽象类使用 new 运算符会导致编译时错误。虽然一些变量和值在编译时的类型可以是抽象的，但是这样的变量和值必须或者为 null，或者含有对非抽象类的实例的引用（此非抽象类是从抽象类派生的）。
允许（但不要求）抽象类包含抽象成员。
抽象类不能被密封。

### 与接口比较
抽象类表示该类中可能已经有一些方法的具体定义，但是接口就仅仅只能定义各个方法的界面（方法名，参数列表，返回类型），并不关心具体细节。
接口是引用类型的，和抽象类的相似之处有三点：
不能实例化；
包含未实现的方法声明；
派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员）。
抽象类与接口紧密相关。然而接口又比抽象类更抽象，这主要体现在它们的差别上：
类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承，从抽象类派生的类仍可实现接口，从而得出接口是用来解决多重继承问题的。
抽象类当中可以存在非抽象的方法，可接口不能，且它里面的方法只是一个声明必须用public来修饰没有具体实现的方法。
抽象类中的成员变量可以被不同的修饰符来修饰，可接口中的成员变量默认的都是静态常量（static final）。
抽象类是对象的抽象，然而接口是一种行为规范。
抽象类里面可以有非抽象方法但接口里只能有抽象方法 声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对像上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口

## 运用要求

### C++
标准c++没有abstract关键字，代之使用纯虚类实现类似的功能，详见词条“虚类”。
在实现接口时，常写一个抽象类，来实现接口中的某些子类所需的通用方法，接着在编写各个子类时，即可继承该抽象类来使用，省去在每个都要实现通用的方法的困扰。

### C#
抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。
接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系。
接口多定义对象的行为;抽象类多定义对象的属性。
如果预计会出现版本问题，可以创建“抽象类”。例如，创建了狗（Dog）、鸡（Chicken）和鸭（Duck），那么应该考虑抽象出动物（Animal）来应对以后可能出现猪马牛的事情。而向接口中添加新成员则会强制要求修改所有派生类，并重新编译，所以版本式的问题最好以抽象类来实现。
从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实现。
对抽象类不能使用new关键字，也不能被密封，原因是抽象类不能被实例化。
在抽象方法声明中不能使用 static 或 virtual 修饰符。

### Java
abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。
在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在 interface中一般不定义数据成员），所有的成员方法都是abstract的。
abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"like-a"关系。
实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。
接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。
抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。
接口中的方法默认都是 public,abstract 类型的。

## 运用实例

### C++
为了让一个类成为抽象类，至少必须有一个纯虚函数。包含至少一个纯虚函数的类视为抽象类。
纯虚函数形式如下：
例如，类A有两个纯虚函数lock()、unlock()和一个虚析构函数：
将函数lock()和unlock()初始化为0使它们成为纯虚函数，没有0这个初使化器，它们仅仅是虚函数。
抽象类对于提供模式、蓝图和后代类遵循的原则有用，如果遵循了蓝图的语义，后代类的行为可能按抽象类提供者和使用者所期望的那样。
通过使用抽象类，C++程序员可以提供C++组件的规范，在它的构建中指导组件的实现者。

### C#
抽象类提供多个派生类共享基类的公共定义，它既可以提供抽象方法，也可以提供非抽象方法。如果派生类没有实现所有的抽象方法，则该派生类也必须声明为抽象类。另外，实现抽象方法由overriding方法来实现。
定义方法为：


### Java
假设在问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close，此时可以通过abstract class或者interface来定义一个表示该抽象概念的类型，定义方式分别如下所示：
使用abstract class方式定义Door：
使用interface方式定义Door：

其他具体的Door类型可以extends使用abstract class方式定义的Door或者implements使用interface方式定义的Door。就此看来，使用abstract class和interface没有大的区别。
但如果需求要求Door还要具有报警的功能，就能得出差别。既然open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中。
对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它有具有报警的功能。说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义。如下所示：
这种实现方式基本上能够明确的反映出对于问题领域的理解，正确的揭示设计意图。

## 运用意义
在面向对象方法中，抽象类主要用来进行类型隐藏。构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；同时，通过从这个抽象体派生，也可扩展此模块的行为功能。为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在。
